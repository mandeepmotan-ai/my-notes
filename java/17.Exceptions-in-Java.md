# Exceptions in Java

## What is an Exception?

- an exception is an **event that disrupts** the normal flow of a program
- it occurs when something unusual happens during program execution (eg, divides by zero, invalid input, file not found, etc)
- **Exceptions are the objects** of type `Throwables`
- with exceptions we can catch and handle broken programs gracefully, without exceptions the program crashes

## Exception Hierarchy in Java

```java
Object
 └── Throwable
      ├── Error (serious problems, not recoverable)
      └── Exception
            ├── Checked Exceptions (must handle)
            └── Unchecked Exceptions (runtime exceptions)
```

- **Error** → JVM-level issues (`OutOfMemoryError`, `StackOverflowError`) → usually not recoverable.
- **Exception** → things you can handle (IO issues, null pointers, etc.).

## Types of Exceptions:

### 1. Checked Exceptions

- known at **compile-time**
- **must be handled** with either `try-catch` or declared with `throws`
- eg, `IQException` , `SQLException` , `ClassNotFoundException`

### 2. Unchecked Exceptions

- occur at **runtime** , compiler does not force handling
- eg, `NullPointerException` , `ArithmeticException` , `ArrayIndexOutOfBoundsException`

## Exception Handling in Java

- Basic Syntax:

```java
try {
    // risky code
} catch(ExceptionType e) {
    // handling code
} finally {
    // cleanup code (always executed)
}
```

## `try-catch` Variations

### 1. Single try-catch

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero!");
}
```

### 2. Multiple catch clauses

```java
try {
    String s = null;
    System.out.println(s.length());
} catch (NullPointerException e) {
    System.out.println("Null pointer!");
} catch (Exception e) {
    System.out.println("Generic exception!");
}
```

- **Rule**: Catch from **most specific → most general**, else → **Unreachable catch block error**.

### 3. Multi-catch block

```java
try {
    int[] arr = new int[3];
    arr[5] = 10;
} catch (ArrayIndexOutOfBoundsException | NullPointerException e) {
    System.out.println("Either array issue or null issue!");
}
```

### 4. try finally (without catch)

```java
try {
    System.out.println("Inside try");
} finally {
    System.out.println("Always executes");
}
```

- useful for resource cleanup (files, DB connections,)

### 5. try-with-resources

- best practice for handling I/O and DB resources
- auto closes resources that implement `AutoCloseable`

```java
try (FileReader fr = new FileReader("test.txt")) {
    // use file
} catch (IOException e) {
    e.printStackTrace();
}
```

## finally block

- Always executes in 2 cases:
    1. `System.exit(0)` is called
    2. JVM shuts down unexpectedly (power, loss, crash)

## throw vs throws

- throw  → used to explicitly throw an exception

```java
if (age < 18) {
    throw new IllegalArgumentException("Age must be >= 18");
}
```

- throws  → used in method signature to declare possible exceptions

```java
public void readFile(String path) throws IOException {
    FileReader fr = new FileReader(path);
}
```

## throws with Inheritance

- Overridden methods must follow rules:
    - If parent doesn’t declare checked exceptions → child cannot add new checked exceptions
    - child can throw fewer or narrower checked exceptions

```java
class Parent {
    void show() throws IOException {}
}
class Child extends Parent {
    @Override
    void show() throws FileNotFoundException {} // allowed (narrower exception)
}
```

## Wrapped Exceptions

- sometimes we can catch a checked exception and re-throw as unchecked:

```java
try {
    readFile("abc.txt");
} catch (IOException e) {
    throw new RuntimeException("File error", e);
}
```

- this is called exception wrapping (used in frameworks)

## Throwable API - common methods

```java
e.getMessage();     // message of exception
e.printStackTrace(); // full stack trace
e.toString();        // class + message
```

## Creating custom exceptions

- extended `Exception` (checked) or `RuntimeException` (unchecked)

```java
class AgeException extends Exception {
    public AgeException(String msg) {
        super(msg);
    }
}

class Test {
    void checkAge(int age) throws AgeException {
        if (age < 18) throw new AgeException("Not allowed");
    }
}
```

## Keys rules:

1. Always catch specific exceptions first
2. Don’t swallow exceptions silently - at least log them
3. use `finally` or `try-with-resources` for cleanup 
4. don’t overuse checked exceptions → balance between robustness and simplicity 
5. wrap exceptions for meaningful error propagation 
6. in android → prefer logging (`Log.e()`) instead of `printStackTrace()`