# Advanced Indexing

Advanced indexing allows us to access or filter data using lists of indices (**Fancy Indexing**) or logical conditions (**Boolean Indexing**). This is significantly more powerful than standard slicing.

### 1. Fancy Indexing

Fancy indexing is the practice of passing a **list of integers** to an array to access multiple non-contiguous rows or columns at once.

- **Standard Slicing:** `a[1:3]` (gives you a range).
- **Fancy Indexing:** `a[[0, 2, 3]]` (gives you exactly those specific rows).

```python
a = np.arange(24).reshape(6,4)

# Accessing specific columns: all rows, but only columns 0, 2, and 3
a[:, [0, 2, 3]]
```

### 2. Boolean Indexing (Filtering)

Boolean indexing allows you to select elements based on a **condition**. When you apply a condition to a NumPy array, it returns a "Boolean Mask" (an array of `True` and `False`). When passed back into the array, only the `True` values are returned.

### Key Logic Operators:

- **`&`**: AND
- **`|`**: OR
- **`~`**: NOT

```python
a = np.random.randint(1, 100, 24).reshape(6, 4)

# 1. Simple Filter: All numbers > 50
a[a > 50]

# 2. Mathematical Filter: Even numbers
a[a % 2 == 0]

# 3. Multiple Conditions: Numbers > 50 AND even
# Note: Use parentheses around each condition
a[(a > 50) & (a % 2 == 0)]

# 4. Negative Condition: Numbers NOT divisible by 7
a[~(a % 7 == 0)]
```

### Summary for Notion

| **Type** | **Example** | **Use Case** |
| --- | --- | --- |
| **Normal** | `a[0:2, 1:3]` | Selecting a continuous block/slice. |
| **Fancy** | `a[[0, 2, 5]]` | Selecting specific, non-sequential rows/cols. |
| **Boolean** | `a[a > 10]` | Filtering data based on specific criteria. |

> Pro Tip: Boolean indexing always returns a 1D array (flattened) because the number of elements that satisfy a condition may not form a perfect rectangular shape.
>