# Binary Search

- it’s like searching a word in dictionary,  we don’t start searching the word from very first page, rather we open around the middle, check, then decide whether to look left or right.
- Binary search exactly does same like finding word in dictionary: *divide* and *conquer*

### Steps:

1. start with `low = 0` , `high = len(arry) -1`
2. find middle index: `mid = (low + high) //2`
3. Compare `arr[mid]` with target:
    1. If equal → found at `mid`
    2. If `target` < `arry[mid]` → Search left half (`high = mid -1`)
    3. If `target` > `arry[mid]` → Search right half (`low = mid +1`)
4. Repeat until found or `low > high` (not found)

### Examples:

1. **Iterative Binary Search**
    
    ```python
    def binary_search(arr, target):
        low, high = 0, len(arr)-1
        
        while low <= high:
            mid = (low + high) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1
    
    nums = [10, 20, 30, 40, 50, 60]
    print(binary_search(nums, 30))  # Output: 2
    print(binary_search(nums, 100)) # Output: -1
    ```
    
2. **Recursive Binary Search**
    
    ```python
    def binary_search_recursive(arr, low, high, target):
        if low <= high:
            mid = (low + high) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                return binary_search_recursive(arr, mid+1, high, target)
            else:
                return binary_search_recursive(arr, low, mid-1, target)
        return -1
    
    nums = [10, 20, 30, 40, 50, 60]
    print(binary_search_recursive(nums, 0, len(nums)-1, 50))  # Output: 4
    ```
    

### Efficiency

- **Time Complexity**: O(log n) (cuts search space in half each time).
- **Space Complexity**: O(1) (iterative) or O(log n) (recursive).