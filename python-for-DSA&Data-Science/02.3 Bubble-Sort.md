# Bubble Sort

- it’s like bubbles rising in water. The heaviest one sink to bottom, lighter one rises
- in bubble sort:
    - we repeatedly compare two adjacent elements in a list
    - if they are in the wrong order → swap them
    - repeat until the full list is sorted
- not used in ML/DS as its too slow
- so in it we start from the starting of the array,
    - take first two elements,
    - compare if the left ones bigger than right one,
        - if yes, shift the right element in left direction at the first one’s index value and move the left element to right one’s index value,  (means bring the smaller value towards left, simple)
        - if no, (means smaller value is already at the left side) so we move to the next pair of adjacent elements (means comparing 3rd vs 4th element)
    - likewise we keep on moving and shifting elements until we reach the end of list and full list gets sorted

### Steps (Ascending Order Example):

1. Compare first two elements. Swap if `arr[i] > arr[i+1]`.
2. Move to next pair, keep swapping.
3. After 1st pass → the largest element "bubbles up" to the end.
4. Repeat process for remaining unsorted part.
5. Stop when no swaps are needed.

### Examples:

1. **Basic Bubble Sort**
    
    ```python
    def bubble_sort(arr):
        n = len(arr)
        for i in range(n):
            for j in range(0, n-i-1):  # last i elements are already sorted
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]  # swap
        return arr
    
    nums = [64, 34, 25, 12, 22, 11, 90]
    print(bubble_sort(nums))  
    # Output: [11, 12, 22, 25, 34, 64, 90]
    ```
    
2. Optimized Bubble Sort (stop if no swaps)
    
    ```python
    def bubble_sort_optimized(arr):
        n = len(arr)
        for i in range(n):
            swapped = False
            for j in range(0, n-i-1):
                if arr[j] > arr[j+1]:
                    arr[j], arr[j+1] = arr[j+1], arr[j]
                    swapped = True
            if not swapped:  # stop early if already sorted
                break
        return arr
    
    nums = [5, 1, 4, 2, 8]
    print(bubble_sort_optimized(nums))
    # Output: [1, 2, 4, 5, 8]
    ```
    

### Efficiency:

- **Time Complexity**:
    - Best Case (already sorted): O(n)
    - Worst/Average Case: O(n²)
- **Space Complexity**: O(1) (in-place sorting)