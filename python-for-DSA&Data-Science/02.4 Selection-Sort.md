# Selection Sort

- kind of picking up the smallest card from a deck and placing it first, and then repeating for the rest
- Selection Sort does the same as above with cards:
    - find the **minimum element** in the unsorted part
    - swap it with the **first element** of the unsorted part
    - **repeat** the same process with next unsorted part till the array gets sorted
- not used in ML/DS as its too slow

### Steps (Ascending Order Example):

1. Start with index `i = 0`.
2. Find smallest element in range `[i … n-1]`.
3. Swap with element at index `i`.
4. Increment `i` and repeat until all sorted.

### Example

1. Basic Selection Sort
    
    ```python
    def selection_sort(arr):
        n = len(arr)
        for i in range(n):
            min_idx = i
            for j in range(i+1, n):
                if arr[j] < arr[min_idx]:
                    min_idx = j
            arr[i], arr[min_idx] = arr[min_idx], arr[i]  # swap
        return arr
    
    nums = [64, 25, 12, 22, 11]
    print(selection_sort(nums))  
    # Output: [11, 12, 22, 25, 64]
    ```
    
2. Selection Sort (Descending Order)
    
    ```python
    def selection_sort_desc(arr):
        n = len(arr)
        for i in range(n):
            max_idx = i
            for j in range(i+1, n):
                if arr[j] > arr[max_idx]:
                    max_idx = j
            arr[i], arr[max_idx] = arr[max_idx], arr[i]
        return arr
    
    nums = [64, 25, 12, 22, 11]
    print(selection_sort_desc(nums))  
    # Output: [64, 25, 22, 12, 11]
    ```
    

### Efficiency:

- **Time Complexity**:
    - Best case = O(n²)
    - Worst case = O(n²)
    - Average case = O(n²)
- **Space Complexity**: O(1) (in-place sorting).

**#Note:** Unlike Bubble Sort, Selection Sort does fewer swaps (at most n), but still O(n²) comparisons.