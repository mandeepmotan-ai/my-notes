# Polymorphism

- **Poly** = many, **Morph** = forms → “many forms.”
- In OOP it means the same function/method name behaves differently depending on the object/class
- In Python, this is achieved through several mechanisms, and it heavily leverages dynamic typing
- it allows code to be reusable and flexible

## Types of Polymorphism in python:

### 1. Duck Typing (Dynamic Typing)

- as it says “If it looks like a duck and quacks like a duck, it’s a duck.”
- In programming terms, this means that the type of an object is less important than the methods or attributes it possesses.
- If an object has the necessary methods to perform a certain operation, Python will allow it, regardless of its actual class
    
    ```python
    class Dog:
        def sound(self): print("Woof!")
    class Cat:
        def sound(self): print("Meow!")
    
    for animal in (Dog(), Cat()):
        animal.sound()   # Woof! / Meow!
    ```
    

### 2. Method Overriding

- redefining parent class’s method that is inherited by child
- child class provides different implementation of parent class
    
    ```python
    class Bird:
        def fly(self): print("Flying in the sky")
    class Penguin(Bird):
        def fly(self): print("Sorry, I cannot fly")
    Penguin().fly()   # Overridden
    ```
    

### 3. Method Overloading (not natively supported in python, simulated)

- same name method but different parameters
- In python, it is simulated using different arguments or `*args`
    
    ```python
    class MathOps:
        def add(self, a, b=0, c=0):
            return a + b + c
    
    obj = MathOps()
    print(obj.add(5))       # 5
    print(obj.add(5, 10))   # 15
    print(obj.add(5, 10, 20))  # 35
    ```
    

### 4. Operator Overloading (Special Methods/ Dunder Methods)

- python allows operators (like `+`, `-`, `*`) to have different meanings depending on the types of operands they are used with
- we can redefine operators for objects
    
    ```python
    class Vector:
        def __init__(self, x, y):
            self.x, self.y = x, y
        def __add__(self, other):   # + operator overloaded
            return Vector(self.x + other.x, self.y + other.y)
    
    v1, v2 = Vector(2, 3), Vector(4, 5)
    v3 = v1 + v2   # calls __add__()
    print(v3.x, v3.y)   # 6 8
    ```