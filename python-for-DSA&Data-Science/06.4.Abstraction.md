# Abstraction

- abstraction means hiding internal implementation details and showing only necessary features
- its kinds of like when we **drive a car** →
    - we use **steering, accelerator, brake** (interface)
    - we don’t worry about how the **engine, fuel injection, or ABS** works (implementation)
- In OOPS, abstraction allows us to focus on what an object does, not how it does it
- example:
    
    ```python
    from abc import ABC, abstractmethod
    
    # Abstract class
    class Shape(ABC):
        
        @abstractmethod
        def area(self):
            pass
    
        @abstractmethod
        def perimeter(self):
            pass
    
    # Concrete classes
    class Rectangle(Shape):
        def __init__(self, length, width):
            self.length = length
            self.width = width
        
        def area(self):
            return self.length * self.width
        
        def perimeter(self):
            return 2 * (self.length + self.width)
    
    class Circle(Shape):
        def __init__(self, radius):
            self.radius = radius
        
        def area(self):
            return 3.14 * self.radius ** 2
        
        def perimeter(self):
            return 2 * 3.14 * self.radius
    
    # Usage
    shapes = [Rectangle(4, 6), Circle(5)]
    for s in shapes:
        print("Area:", s.area(), "| Perimeter:", s.perimeter())
        
        
    #we didn’t care about the exact formula inside area() or perimeter() when using shapes.
    ```