# Iterators

- Iterators are a fundamental concept for data traversal and processing
- they provide a way to access elements of a a collection one at a time, without loading the entire collection in memory
- this is known as “**lazy evaluation“ and this** makes iterators incredibly useful for handling large data sets, streams of data and even infinite sequences

## The Iterator protocol

For any object to behave like an iterator, it must follow the iterator protocol, i.e. implement two methods:

- `__iter__()`  : returns the iterator object itself
- `__next__()`  : returns the next item in sequence. Raises **`StopIteration`** when no items are left

## Iterable vs Iterator

- **Iterable** : it is the object which is to be loop over (iterated) like list, dicts, sets, tuples, etc.
    - `iter(iterable)` function takes an iterable object and returns iterator for the object
- **Iterator** : the actual object that produces values one by one. 
Implements both `__iter__()` and `__next__()`
    - `next(iterator)` function takes an iterator object and returns the next items from iterator and if the iterator is exhausted (means no more values left ahead), it raises **`StopIteration`** exception

## How `for` loops works internally

when we use for loop in python, it automatically handles the iterator protocol for us 

- it calls `iter()` on the iterable object to get an iterator
- it reportedly calls the next() on the iterator to fetch the next element
- it catches the `StopIterator` exception to know when to stop the iteration

## Practical Use Cases and Examples

Iterators shine in scenarios where memory efficiency and on-demand data generation are crucial.

### 1. Memory-Efficient Looping Over Large Datasets

When dealing with large files or datasets that cannot fit entirely into memory, iterators are indispensable.

**Example: Reading a Large File**

```python
# Assume 'large_data.txt' is a very large text file
try:
    with open('large_data.txt', 'r') as file:
        # The file object itself is an iterator, yielding lines one by one
        for line in file:
            # Process each line without loading the whole file
            print(line.strip())
except FileNotFoundError:
    print("Error: large_data.txt not found.")
```

In this example, `file` is an iterable, and the `for` loop implicitly gets an iterator from it. Each `line` is processed as it's read, preventing memory exhaustion.

### 2. Custom Iteration Logic

You can create your own iterator classes to define custom iteration behaviors. This is useful for custom data structures or when you need specific logic for generating sequences.

**Example: A Custom Iterator for Even Numbers**

```python
class EvenNumbers:
    def __init__(self, max_val):
        self.max_val = max_val
        self.current = 0

    def __iter__(self):
        # Returns the iterator object itself
        return self

    def __next__(self):
        # Generates the next even number
        if self.current >= self.max_val:
            raise StopIteration
        else:
            result = self.current
            self.current += 2
            return result

# Usage
even_gen = EvenNumbers(20)
for num in even_gen:
    print(num)
```

This `EvenNumbers` class creates an iterator that yields even numbers up to a specified maximum value.