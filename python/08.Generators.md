# Generators

- **generator** is a special type of iterator created using `yield` instead of `return`
- it works same as `next()` but in a function with returning single element at a time
- unlike `return` which just returns whole result or items at once, generator function **“yields”** sequence of values, one at a time

### How Generators work

- generator function is defined just as normal function but instead of using `return` , `yield` is used
- when we iterate over generator object using `next()` or `for` loop , `yield` provides one value at a time and code executes back from where it left earlier processing next element
- the value after `yield` is the one returned. The state of the function (including local variables and the instruction pointer) is saved, and the function is paused. When the next value is requested, the function resumes from where it left off

## Creating Generators

1. **Generator Function:**
    
    ```jsx
    def squares(n):
        for i in range(1, n+1):
            yield i*i //just use of yield instead of return
    
    gen = squares(5)
    print(next(gen))  # 1
    print(next(gen))  # 4
    ```
    
2. **Generator Expression:**
    
    ```jsx
    squares = (x*x for x in range(5))  //just use () instead of [] 
    print(next(squares))  # 0
    print(list(squares))  # [1, 4, 9, 16]
    
    ```
    

## **Key Use cases of Generators**

1. **Processing Large Files:** Reading a large file into memory all at once can be a problem, especially if the file is larger than your available RAM. Generators provide a perfect solution for this
2. **Infinite Sequences: s**ometimes you need to work with sequences that are conceptually infinite, like the Fibonacci sequence. A regular function can't return an infinite list, but a generator can `yield` values indefinitely
3. **Data Streaming and Pipelines: I**n data processing pipelines, you often need to perform a series of transformations on data. Generators are excellent for this, as they allow you to chain operations together efficiently

### **Practical Implementation: A Simple Example**

Let's create a simple generator to produce a sequence of even numbers.

```jsx
def even_number_generator(n):
    """
    A generator that yields even numbers up to n.
    """
    i = 0
    while i <= n:
        yield i
        i += 2

# Using the generator
even_gen = even_number_generator(10)

# Iterate through the generator
print("Using a for loop:")
for num in even_gen:
    print(num)

# Resetting and using the generator with next()
print("\nUsing next() to get numbers one by one:")
even_gen_2 = even_number_generator(6)
print(next(even_gen_2))  # Output: 0
print(next(even_gen_2))  # Output: 2
print(next(even_gen_2))  # Output: 4
print(next(even_gen_2))  # Output: 6
# print(next(even_gen_2))  # This will raise a StopIteration error
```