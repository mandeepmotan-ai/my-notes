# NumPy

- **python library** used for fast **mathematical operations** on large data
- used for scientific computing in python
- it provides support for arrays and matrices, along with a collection of mathematical functions to operate on these data structures
- Provides the **ndarray** object (N-Dimensional Array) → similar to lists but:
    - Faster (written in C under the hood)
    - Memory-efficient
    - Supports vectorized operations (no need for Python loops

## Creating array

```python
import numpy as np

# From Python list
arr = np.array([1, 2, 3, 4])
print(arr)  # [1 2 3 4]

# Multi-dimensional array
mat = np.array([[1, 2, 3], [4, 5, 6]])
print(mat)  
# [[1 2 3]
#  [4 5 6]]

# Using built-in methods
zeros = np.zeros((2,3))     # 2x3 matrix of zeros
ones = np.ones((3,3))       # 3x3 matrix of ones
rand = np.random.rand(2,2)  # 2x2 random values (0-1)
ar = np.arange(1, 10, 2)    # [1, 3, 5, 7, 9]
```

## Array Properties

```python
arr = np.array([[1,2,3],[4,5,6]])
print(arr.shape)   # (2, 3) → rows, cols
print(arr.ndim)    # 2 → dimensions
print(arr.size)    # 6 → total elements
print(arr.dtype)   # int64 → data type
```

## Indexing and Slicing

```python
arr = np.array([10, 20, 30, 40, 50])
print(arr[0])       # 10
print(arr[1:4])     # [20 30 40]

mat = np.array([[1,2,3],[4,5,6]])
print(mat[0,1])     # row=0, col=1 → 2
print(mat[:,2])     # all rows, col=2 → [3 6]
```

## Vectorized Operations

```python
a = np.array([1,2,3])
b = np.array([4,5,6])

print(a + b)   # [5 7 9]
print(a * b)   # [ 4 10 18]
print(a ** 2)  # [1 4 9]
print(np.sqrt(a))  # [1. 1.414 1.732]
```

#we don’t need to run any loops, numpy runs operation on each element 

## Matrix Operations

```python
A = np.array([[1,2],[3,4]])
B = np.array([[5,6],[7,8]])

print(A.dot(B))       # Matrix multiplication
print(np.transpose(A))  # Transpose
print(np.linalg.inv(A)) # Inverse
print(np.linalg.det(A)) # Determinant
```

## Statistical Operations

```python
arr = np.array([1,2,3,4,5])
print(np.mean(arr))   # 3.0
print(np.median(arr)) # 3.0
print(np.std(arr))    # Standard deviation
print(np.sum(arr))    # 15
print(np.max(arr))    # 5
```

# Advanced NumPy

## Array Creation Tricks

```python
import numpy as np

# linspace: evenly spaced numbers
arr1 = np.linspace(0, 1, 5)   # [0.  0.25 0.5 0.75 1.]

# logspace: numbers on log scale
arr2 = np.logspace(1, 3, 3)   # [10. 100. 1000.]

# identity matrix
I = np.eye(3)   # 3x3 identity

# diagonal matrix
diag = np.diag([1, 2, 3])
```

## Broadcasting

- performing operations on arrays of different shapes without writing loop

```python
a = np.array([1, 2, 3])
b = 2
print(a * b)  # [2 4 6]

# 2D broadcasting
X = np.array([[1], [2], [3]])
Y = np.array([10, 20, 30])
print(X + Y)
```

## Fancy Indexing and Boolean Masking

```python
arr = np.array([10, 20, 30, 40, 50])

# fancy indexing
print(arr[[0, 2, 4]])   # [10 30 50]

# boolean masking
mask = arr > 25
print(arr[mask])        # [30 40 50]
```

## Views vs Copies

a view shares data with original array and copy does not

```python
arr = np.arange(5)
view = arr[1:4]
view[:] = 99
print(arr)  # [ 0 99 99 99  4] (changed original!)

copy = arr[1:4].copy()
copy[:] = 77
print(arr)  # original unchanged
```

## Stacking and Splitting

combine or break arrays

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# stack
print(np.stack((a, b)))       # [[1 2 3] [4 5 6]]
print(np.hstack((a, b)))      # [1 2 3 4 5 6]
print(np.vstack((a, b)))      # [[1 2 3] [4 5 6]]

# split
arr = np.arange(9)
print(np.split(arr, 3))       # [array([0,1,2]), array([3,4,5]), array([6,7,8])]
```

## Linear Algebra Operations

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[2, 0], [1, 2]])

# matrix multiplication
print(A @ B)

# determinant
print(np.linalg.det(A))

# inverse
print(np.linalg.inv(A))

# eigenvalues & eigenvectors
vals, vecs = np.linalg.eig(A)
print(vals, vecs)
```

## Random Module

```python
np.random.seed(42)   # reproducibility

print(np.random.rand(2, 3))   # uniform [0,1)
print(np.random.randn(2, 3))  # normal distribution
print(np.random.randint(1, 10, (2, 2)))  # integers
```

## Advanced Statistics

```python
arr = np.array([1, 2, 3, 4, 5])

print(np.percentile(arr, 50))  # median
print(np.corrcoef(arr, arr))   # correlation matrix
print(np.histogram(arr, bins=3))
```

## Performance Tricks

- Use **vectorization** instead of Python loops.
- Use `np.where` for conditional selection:

```python
arr = np.array([1, 2, 3, 4, 5])
print(np.where(arr % 2 == 0, "Even", "Odd"))
```

- Use `np.vectorize` to apply a function over arrays.
- Use `dtype=np.float32` instead of float64 for speed in ML models.