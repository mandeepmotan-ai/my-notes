# References: Objects and Arrays

## Arrays in JavaScript

- arrays are ordered list of values (indexed, starting from 0)

### ways to create arrays:

1. Using **literal** (most common) : `let arr1 = [1, 2, 3, 4];`
2. Using **Array Constructor** : `let arr2 = new Array(1, 2, 3, 4);`
3. create empty array to push later : `let arr3 = [];`

### **common array methods:**

```jsx
// Adding / Removing
nums.push(6);     // add at end → [1,2,3,4,5,6]
nums.pop();       // remove from end → [1,2,3,4,5]
nums.unshift(0);  // add at start → [0,1,2,3,4,5]
nums.shift();     // remove from start → [1,2,3,4,5]

// Checking & Searching
nums.includes(3); // true
nums.indexOf(4);  // 3 (position)

// Join & Split
let str = nums.join("-"); // "1-2-3-4-5"

// Slice & Splice
let part = nums.slice(1,3);   // [2,3] (non-destructive)
nums.splice(2, 1, 99);        // removes 1 at index2, adds 99 → [1,2,99,4,5]

// Spread & Concat
let arrA = [1,2], arrB = [3,4];
let combined = [...arrA, ...arrB]; // [1,2,3,4]
```

## Objects in JavaScript

- simple, Objects = (key, value) pairs     (just like dictionary in python)
- keys are usually strings and values can be anything  (string, number, array, object, function)

### Creating Objects:

```jsx
// 1. Object literal
let person = {
    name: "Mandeep",
    age: 21,
    isDev: true
};

// 2. Using new Object()
let user = new Object();
user.name = "Rahul";
user.age = 25;
```

### Accessing Values:

```jsx
console.log(person.name);    // dot notation
console.log(person["age"]);  // bracket notation (useful when key is dynamic)
```

## Stack vs Heap (Memory model)

- **Primitive type values** (numbers, strings, boolean, null, undefined, symbol) are stored in stack, **copied by value**
    - very fast access, **fixed-size memory allocation**
- **Reference types** (array, object, function) are stored in heap, variable holds a reference of object **(copied by reference)**
    - **memory allocated dynamically,** larger and flexible
    - variables on the stack hold **a pointer to heap memory**
- example:
    
    ```jsx
    let a = 10;   // stack
    let b = a;    // new copy
    b = 20;
    console.log(a); // 10 (independent copy)
    
    let obj1 = {name: "Mandeep"};  // heap
    let obj2 = obj1;               // same reference
    obj2.name = "Rahul";
    console.log(obj1.name);        // Rahul (both point to same)
    ```
    

## Shallow copy vs Deep copy

- **Shallow Copy** → copies reference of nested objects → changes affect both
- **Deep Copy** → creates completely new copy including nested objects.

## Array Higher Order Methods

- `let nums = [1, 2, 3, 4, 5];`
1. **map()**
    - used to iterate over all items and perform a function on all
    - `let doubled = nums.map(n => n * 2); // [2, 4, 6, 8, 10]`
2. **filter()**
    - filter items based on certain condition provided
    - `let evens = nums.filter(n => n % 2 === 0); // [2, 4]`
3. **reduce()**
    - process array from left to right and do a call back function on all items kind of adding all items to acculmulator
    - **syntax:** `array.reduce(callback(accumulator, currentValue, currentIndex, array), initialValue)`
    - example:
        
        ```jsx
        const numbers = [1, 2, 3, 4];
        const sum = numbers.reduce((acc, curr) => acc + curr, 0);
        console.log(sum); // Output: 10
        ```