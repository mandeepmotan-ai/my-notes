# Call Stack and Hoisting

## Hoisting

- it’s is JavaScript’s default **behavior of moving declarations (not initializations)** to the top of the current scope (globe or function scope) during the compilation phase
- its kinda, before execution JS scans the whole JS code, registers variables and functions in memory, then executes code line by line

## Variable Hoisting

- depends on the type of variable either `var` , `let` or `const`

### `var`

- variable declared as `var` or hoisted and initialized as `undefined`
- this is the reason why we can *access the var variables before the line of declaration* but we get `undefined`

### `let` and `const`

- hoisted but kept in **Temporal Dead Zone (TDZ)** until the declaration is reached
- **TDZ**: The time between variable hoisting and its declaration is called the *Temporal Dead Zone*.
- this is why accessing them before declaration throws `ReferenceError`

## Function Hoisting

- depends on the type of function:

### Function Declarations

- fully hoisted (definition + body)
- they can be called before declaration

```jsx
sayHi(); // ✅ "Hello"
function sayHi() {
  console.log("Hello");
}
```

### Function Expressions

- treated like variables
- just the declaration is hoisted, not the assigned function

```jsx
sayHello(); // ❌ TypeError: sayHello is not a function
var sayHello = function() {
  console.log("Hello");
};
```

### Arrow Functions

- also function expressions, so only the variable name is hoisted
- they behave the same as `let`/`const` (if declared with them)

```jsx
sayBye(); // ❌ ReferenceError (TDZ)
const sayBye = () => {
  console.log("Bye");
};
```

## Function Calling

- calling a function simply mean executing it by using `()` front of function name
- but calling depends on *where* and *when* we declare  the function

```jsx
// Function declaration
hello(); // ✅ Works
function hello() {
  console.log("Hello World");
}

// Function expression with var
hi(); // ❌ TypeError
var hi = function() {
  console.log("Hi");
};

// Arrow function with const
hey(); // ❌ ReferenceError
const hey = () => {
  console.log("Hey");
};
```

## Stack vs Hoisting Relationship

- During compilation:
    - memory is allocated in the heap (objects, functions)
    - variables and function names are stored in execution context’s memory space (stack)
- when the code runs, JS uses this memory reference (stack) to resolve variables and functions
- that’s why hoisting works → because JS already knows about their existence

***#Classes in JavaScript are not hoisted like functions***