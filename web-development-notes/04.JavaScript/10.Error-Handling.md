# Error Handling

## Error Handling

- error handling is way to manage errors when they occur during run time

```jsx
console.log("Before error");
let x = y + 10; // ❌ ReferenceError: y is not defined
console.log("After error"); // never runs
```

## `try catch` block

- `try` block is where *error prone code* is put in
- `catch` block is used to *catch the error* and stop it from unnecessary stopping the program
- syntax:
    
    ```jsx
    try {
      // Code that might throw an error
    } catch (error) {
      // Code that runs if error occurs
    }
    ```
    
- example:
    
    ```jsx
    try {
      let result = 10 / something; // ❌ ReferenceError
      console.log(result);
    } catch (err) {
      console.log("Error caught:", err.message); 
    }
    console.log("Code continues running ✅");
    ```
    

## `finally` block

- this *block of code always runs,* no matter if error occurred or not
- useful for cleanup tasks (closing DB connection, removing event listeners, etc.)
    
    ```jsx
    try {
      console.log("Trying risky code...");
      let num = 10 / 0; // Infinity, not an error
    } catch (err) {
      console.log("Error caught:", err.message);
    } finally {
      console.log("Always runs (cleanup work)");
    }
    ```
    

## `throw` custom errors

- we can create and throw our own errors using `throw`
- use cases: input validation, API failures, security checks
    
    ```jsx
    function withdraw(amount) {
      if (amount <= 0) {
        throw new Error("Withdrawal amount must be positive!");
      }
      return `Withdrew $${amount}`;
    }
    
    try {
      console.log(withdraw(-100)); 
    } catch (err) {
      console.log("Custom error:", err.message);
    }
    ```
    

## **Built-in Error Types in JS**

JavaScript already provides common error objects:

- `Error` → generic error
- `ReferenceError` → using undeclared variable
- `TypeError` → wrong type of value
- `SyntaxError` → invalid JS syntax
- `RangeError` → value out of range
- `EvalError` → bad use of `eval()` (rare)

```jsx
try {
  null.toUpperCase(); // ❌ TypeError
} catch (err) {
  console.log(err.name);    // "TypeError"
  console.log(err.message); // "Cannot read properties of null..."
}
```

## **Custom Error Classes (Advanced)**

for structured error handling, you can define your own error types.

```jsx
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

function registerUser(username) {
  if (!username) throw new ValidationError("Username is required!");
  return "User registered: " + username;
}

try {
  registerUser(""); 
} catch (err) {
  console.log(err.name);    // "ValidationError"
  console.log(err.message); // "Username is required!"
}
```