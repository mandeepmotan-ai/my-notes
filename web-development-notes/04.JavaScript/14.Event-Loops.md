# Event Loops

JavaScript is a single threaded language, so it can only execute one piece of code at a time.

But modern apps today need to do lots of tasks together to be highly User Interactive, So this all is done by JavaScript without blocking the page with the help of “**event loop”** which is used to manage concurrency and asynchronous  behavior

## The JavaScript Runtime Environment

To truly understand event loops, we must first know its components:

### 1. Call Stack

- where asynchronous JavaScript code is executed
- it works on LIFO (Last-In-First-Out) data structure
- when a function is called it’s pushed on to the call stack, when it returns its popped off
- as we know JS executes one thing at a time, and that one thing is what is at the top of call stack

### 2. Web API

- not part of JS engine itself but provided by the browser
- these include functionalities like `DOM` events, `setTimeout()` , `fetch()`
- this allows us to perform task that would otherwise block the main thread

### 3. The Task Queues/ Call back Queues

There are two main types of queues, where asynchronous tasks wait to be executed:

- **The Micro task Queue(Job Queue)** :
    - higher priority queue
    - holds pending call backs for `Promises` and `async` / `wait` functions as well as `queueMicroTasks()`
- The Macro task Queue(Call back Queue) :
    - lower priority queue
    - holds callback for `setTimeout()` , `setInterval()` , I/O operations , and DOM events

### 4. The Event Loop

- simplest yet powerful orchestrator (kind of acts as a traffic controller)
- it’s a continuously running process that performs a single, critical-check: **“Is the Call Stack Empty?”**  and If it is empty the Event Loop takes a task from one of the queues and pushes it to the Call Stack to be executed

## How the Event Loop works?

this entire process works in constant cycle

1. **Initial Process** : the JS engine starts by executing all the asynchronous code from our script, pushing and pulling functions from the Call Stack as it goes
2. **Asynchronous Call** : when the engine encounters an asynchronous function, it doesn’t wait for it to finish. *Synchronous tasks run first* 
3. **Offloading to Web API’s**  : The asynchronous function is sent to appropriate web API to handle the task in background. The call back function is passed along the Web API and the main thread is free to continue executing the rest of synchronous code
4. **Completion and Queuing** : Once the Web API’s task is done, it doesn’t put the `callback` directly back on the call stack. Instead it places the `callback` into the appropriate Task Queue (either **Macro Task** or **Micro Task**)
5. **The Event Loop’s Check** : the event loop simply monitors the call stack, if it is empty or not. and when it is empty means all the synchronous code is done execution. The Event Loop performs a crucial check:
    1. It firstly check **Micro Task Queue,** if there are any callbacks waiting, it pushes all of them onto the Call Stack and executes them one by one, until the microtask queue is empty
    2. Once the **Micro Task queue** is empty, the Event Loop checks the Macro Task Queue. It takes the first callback in the queue and pushes it to the Call Stack
6. **Repeats forever** : This cycle then repeatedly continues. The Call Stack executes the new function, and when it’s empty again, Event Loop checks the queue and again push the task in call stack

### The Importance of Queue Priority: Micro tasks vs. Macro tasks

This is a key detail that trips up many developers. The Event Loop prioritizes the Microtask Queue.

**The Golden Rule:** The Event Loop will always process all pending microtasks before processing the next single macrotask.