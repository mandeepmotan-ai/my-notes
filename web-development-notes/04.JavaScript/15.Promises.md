# Promises

- **a promise** in JavaScript is an object that represents the *future result of an asynchronous operation*
- itâ€™s kind of like a placeholder for a value that we donâ€™t have yet, but will get later
- itâ€™s a fundamental way of handling asynchronous code in a cleaner, more readable, and more manageable way than traditional call backs
- A Promise can be in one of three states:
    - **pending** : initial state, asynchronous operation has yet not completed
    - **fulfilled or resolved** : the operation completed successfully and the promise now holds a resulting value
    - **rejected** : the operation failed, and the promise holds an error reason
- once a promise is either `fulfilled` or `rejected`, it is considered **`settled`**. A settled promise can never change its state again

## Creating a Promise

- we can create a promise using the `Promise` constructor, which takes a single function called the **executor.**
- **the executor** function takes two argument, both of which are provided by JavaScript engine:
    - `resolve` : a function to call when the asynchronous function completes successfully. we pass the successful result as an argument to `resolve()`
    - `reject` : a function to call when the asynchronous function fails. we pass the error object as argument to `reject()`

```jsx
const promise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve("Order completed ðŸ•");
  } else {
    reject("Order failed âŒ");
  }
});
```

## Consuming a Promise (`.then()`, `.catch` , `.finally()`)

once we have promise we use its methods to handle the eventual result 

### 1. `.then()`

- handle a promiseâ€™s fulfillment
- takes two arguments both of which are call back functions:
    - first argument **fulfillment handler**, which runs if the promise is `fulfilled` . It receives the resolved value
    - second argument (optional) rejection handler, which runs if the promise is rejected . It receives the error reason

```jsx
myPromise.then((value) => {
  console.log(value); // Logs: 'Success! Data has been fetched.'
});
```

### 2. `.catch()`

- a cleaner way to handle promise rejections
- itâ€™s a shorthand for `.then(null, rejectionHandler)`
- highly recommended for error handling

```jsx
const anotherPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Failed to load data.'));
  }, 1000);
});

anotherPromise
  .then((value) => {
    // This part is skipped because the promise was rejected
    console.log(value);
  })
  .catch((error) => {
    console.error('Caught an error:', error.message); // Logs: 'Caught an error: Failed to load data.'
  });
```

### 3. `.finally()`

- executes the callback function when the promise is settled, regardless of whether it was `fulfilled` or `rejected`
- useful for cleanup task such as hiding a loading spinner or closing a connection

```jsx
myPromise
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.error(error.message);
  })
  .finally(() => {
    console.log('Promise is now settled. Loading is complete.');
    // Hide the loading indicator
  });
```

## Promise Chaining

- a powerful feature of promises is that they can be chained
- `.then()` and `.catch()` methods always returns a new promise, allowing us to sequence asynchronous operations
- **Key Rule** : the value returned from a .then() and .catch() callback becomes the resolved value of the next promise in the chain

```jsx
function fetchUserData(userId) {
  return new Promise((resolve) => {
    setTimeout(() => resolve({ id: userId, name: 'John Doe' }), 1000);
  });
}

function processUserData(user) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(`Processed user: ${user.name}`), 500);
  });
}

// Chain the promises
fetchUserData(123)
  .then((userData) => {
    console.log('User data fetched:', userData);
    // Return a new promise from the next operation
    return processUserData(userData); 
  })
  .then((processedMessage) => {
    // The value from the previous .then() becomes the argument here
    console.log(processedMessage); // Logs: 'Processed user: John Doe'
  })
  .catch((error) => {
    console.error('An error occurred in the chain:', error);
  });
```

## Static Promise Methods

the promise object also provides several useful static methods for handling  multiple promises at once.

### 1. `Promise.all()`

It takes an array of promises and returns a single promise. This runs all promises in parallel. This returned promise:

**Basic Syntax** : `Promise.all([p1, p2, ...])`

- `fulfills`  when all of the input promises are filled. The value is an array of their resolved values, in the same order as the input array
- `rejects` as soon as any of the input promises an object. The reason is the error of the first promise that rejected

```jsx
Promise.all([
  Promise.resolve("A"),
  Promise.resolve("B"),
  Promise.resolve("C")
]).then(values => console.log(values)); // ["A", "B", "C"]
```

### 2. `Promise.race()`

- it takes an array of promises and returns a single promise that settles as soon as one of the input promises settles (either `fulfilled` or `rejected`)
- the result is the value or error of the first promise to settle
- **Basic Syntax** : `Promise.race([p1, p2, ...])`

```jsx
Promise.race([
  new Promise(res => setTimeout(() => res("Fast â±ï¸"), 500)),
  new Promise(res => setTimeout(() => res("Slow ðŸ¢"), 2000))
]).then(value => console.log(value)); // "Fast â±ï¸"
```

### 3. `Promise.settled()`

- resolves when all promises settle (success or failure)
- returns array of objects with `{status , value | reason}`
- **Basic Syntax** : `Promise.allSettled([p1, p2, ...])`

```jsx
Promise.allSettled([
  Promise.resolve("âœ…"),
  Promise.reject("âŒ")
]).then(results => console.log(results));
```

### 4. `Promise.any()`

- resolves with first fulfilled promise
- If all rejects â†’ throws an `AggregatedError`

**Basic Syntax** : `Promise.any([p1, p2, ...])`

```jsx
Promise.any([
  Promise.reject("âŒ"),
  Promise.resolve("âœ… First Success"),
  Promise.resolve("Another Success")
]).then(result => console.log(result)); // âœ… First Success
```

## Promises vs Callbacks

Before Promises, async used **callbacks** â†’ callback hell

```jsx
// Callback hell
getData(function(a) {
  process(a, function(b) {
    save(b, function(c) {
      console.log(c);
    });
  });
});
```

With Promises â†’ **clean, readable, chainable**.

```jsx
getData()
  .then(process)
  .then(save)
  .then(console.log);

```