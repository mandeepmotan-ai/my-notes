# Async/Await

- modern JS syntax introduced in ES2017
- it provides more straightforward way to work with asynchronous code
- built on top of promises, it makes *asynchronous operations look and behave like synchronous code,* significantly improving readability and improves error handling

## How it works

1. `async` function : 
    1. a function declared with `async` keyword always returns a promise. 
    2. If the function returns value, promise is fulfilled with that value
    3. If the function throws an error, promise is rejected with that error
        
        ```jsx
        async function greet() {
          return "Hello ðŸ‘‹";
        }
        
        greet().then(console.log); // "Hello ðŸ‘‹"
        ```
        
2. `await` keyword : 
    1. it can only be used inside async function
    2. it pauses the execution of async function until the promise it is waiting for is fulfilled or rejected 
    3. when the promise is fulfilled, value of the `await` expression is fulfilled value
    4. if the promise is rejected, `await` throws an error

### Basic Syntax:

```jsx
// A simple function that returns a promise
function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('Resolved!');
    }, 2000);
  });
}

// An async function that uses await
async function asyncCall() {
  console.log('Calling...');
  
  // The function pauses here until the promise resolves
  const result = await resolveAfter2Seconds(); 
  
  console.log(result); // This line runs after the 2-second delay
  // Expected output: "Resolved!"
}

asyncCall();
```

### The `async`/`await` flow of the above code

1. when `asyncCall()` is invoked, it starts execution 
2. `console.log('Calling...');` runs immediately
3. then the `await resolveAfter2Seconds();` is encountered
4. the `asyncCall()` function is paused at this point. It does not block the main thread, instead control is returned to the event loop
5. after the `resolveAfter25seconds` promise is  resolved (after 2 secs), the `asyncCall()` function resumes execution after from where it is left off
6. the resolved value (â€™`Resolved`â€™) is assigned to the `result` variable
7. `console.log(result);` is executed and the function is completed

## Error Handling with `tryâ€¦catch`

- unlike Promise (`.catch()`), with async we can use `tryâ€¦catch` , just like we did with synchronous code
- this is much cleaner than chaining `.then() .catch()` calls
    
    ```jsx
    function rejectAfter1Second() {
      return new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Promise rejected!'));
        }, 1000);
      });
    }
    
    async function handleRejection() {
      try {
        const result = await rejectAfter1Second();
        console.log(result); // This line will not be reached
      } catch (error) {
        console.error('Caught an error:', error.message);
        // Expected output: "Caught an error: Promise rejected!"
      }
    }
    
    handleRejection();
    ```
    

## Handling Multiple Awaits

if we have multiple asynchronous operations that are not depended on each other, awaiting them sequentially is inefficient because the second operation wonâ€™t start until the first one is complete 

### Inefficient (Sequential `await`s)

```jsx
async function getSequentialData() {
  const user = await fetch('https://api.example.com/user'); // waits for this to finish (e.g., 1 sec)
  const posts = await fetch('https://api.example.com/posts'); // then waits for this (e.g., 1 sec)

  console.log(user, posts); // Total time: approx. 2 seconds
}
```

### Efficient (Parallel `await`s using `Promise.all`)

- best practice is to start all Promises at once and then `await` them using `Promise.all`
- this runs the operation in parallel
    
    ```jsx
    async function getParallelData() {
      // Start both fetch operations at the same time
      const userPromise = fetch('https://api.example.com/user');
      const postsPromise = fetch('https://api.example.com/posts');
    
      // Await the resolution of all promises in the array
      const [userResponse, postsResponse] = await Promise.all([userPromise, postsPromise]);
    
      const userData = await userResponse.json();
      const postsData = await postsResponse.json();
      
      console.log(userData, postsData); // Total time: approx. 1 second
    }
    ```
    

### `Async` vs `Promises`

| Feature | Promises (`.then()`) | Async/Await |
| --- | --- | --- |
| Readability | Nested, chain-heavy | Looks synchronous |
| Error handling | `.catch()` | `try...catch` |
| Parallel tasks | `Promise.all` | `Promise.all` |
| Return values | Explicit `.then()` | Direct `return` |
| Debugging | Harder stack traces | Cleaner stack traces |