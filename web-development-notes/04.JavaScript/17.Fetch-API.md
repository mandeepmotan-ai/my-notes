# Fetch API

- fetch API is a built-in browser API that provides modern, powerful and flexible interface for making network requests in browser
- replaces old `XMLHttpRequest` (XHR)
- works with promises making async requests much cleaner

### Basic Syntax:

- core of Fetch API is global `fetch()` method
- it takes one mandatory argument `url`
- `fetch()` method returns a promise that resolves to a `Response` object. The Promise is resolved as soon as the server responds with headers, even if the response is an HTTP error status

```jsx
fetch(url, options)
  .then(response => {
    // response object (not the data yet)
  })
  .catch(error => {
    console.error("Error:", error);
  });
```

### The two step process

- **`Request` and `Response` object** : Call `fetch()` and handle the initial Promise resolution, which gives us the `Response` object
- **Extracting the body** : use a method on the response object to extract the actual data. The response objects has methods like `json()` , `text()` , `blob()` , etc all of which returns as promise

## Example:

a classic way to use fetch API

1. **a simple `GET` request**
    
    ```jsx
    fetch('https://api.example.com/data')
      .then(response => {
        // Check if the response was successful (status 200-299)
        if (!response.ok) {
          // If not, throw an error to trigger the .catch() block
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        // Parse the response body as JSON. This also returns a promise.
        return response.json();
      })
      .then(data => {
        // The JSON data is now available
        console.log(data);
      })
      .catch(error => {
        // This catches network errors and the errors thrown above
        console.error('There was a problem with the fetch operation:', error);
      });
    ```
    
2. **simple `GET` request with `async` and `await`  (modern, preferred way)**
    
    ```jsx
    async function fetchData() {
      try {
        // Step 1: Await the response
        const response = await fetch('https://api.example.com/data');
    
        // Check for HTTP errors
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
    
        // Step 2: Await the JSON parsing
        const data = await response.json();
        
        console.log(data);
      } catch (error) {
        console.error('Fetch operation failed:', error);
      }
    }
    
    fetchData();
    ```
    

### Making a `POST` request

`fetch()` function can be configured using a second optional argument: an `options` object. This object allow us to specify the HTTP method, headers, body and more

**Example sending JSON data to an API**

```jsx
const postData = {
  title: 'My New Post',
  body: 'This is the content of the post.',
  userId: 1,
};

async function postNewData() {
  try {
    const response = await fetch('https://api.example.com/posts', {
      method: 'POST', // Specify the method
      headers: {
        'Content-Type': 'application/json', // Set the content type
      },
      body: JSON.stringify(postData), // Convert the data to a JSON string
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log('Post created successfully:', data);
  } catch (error) {
    console.error('Failed to create post:', error);
  }
}

postNewData();
```

### Key `options` for the `fetch()` method

The `options` object can include many useful properties:

- **`method`**: The HTTP method (`'GET'`, `'POST'`, `'PUT'`, `'DELETE'`, etc.). The default is `'GET'`.
- **`headers`**: An object to set HTTP request headers (e.g., `{'Content-Type': 'application/json'}`).
- **`body`**: The request body for methods like `POST` and `PUT`. Can be a `String`, `FormData`, `Blob`, `ArrayBuffer`, etc.
- **`mode`**: The request mode (`'cors'`, `'no-cors'`, `'same-origin'`).
- **`cache`**: The cache mode (`'default'`, `'no-cache'`, `'reload'`, `'force-cache'`).
- **`credentials`**: The credentials mode (`'omit'`, `'same-origin'`, `'include'`) to control whether cookies or authorization headers are sent with the request.

### Handling Different Response Types

The `Response` object has several methods to handle different data types:

- `response.json()`: Parses the response as JSON.
- `response.text()`: Reads the response as plain text.
- `response.blob()`: Reads the response as a `Blob` (useful for images or binary data).
- `response.formData()`: Reads the response as `FormData`.
- `response.arrayBuffer()`: Reads the response as a generic binary data buffer.

### Common Pitfalls and Best Practices

- **Network vs. HTTP Errors:** The `fetch()` promise only rejects on **network errors** (e.g., a connection problem). It does **not** reject for HTTP errors like 404 or 500. You must explicitly check `response.ok` or `response.status` to handle these.
- **Response Body:** The `Response` body can only be consumed once. If you call `response.json()` and then try to call `response.text()` on the same `Response` object, the second call will fail.
- **CORS:** Cross-Origin Resource Sharing (CORS) is a security mechanism that can block cross-origin requests. If you are fetching data from a different domain, the server must be configured to allow it.
- **`async/await` for Readability:** Always prefer `async/await` over `.then()` chains for complex asynchronous flows. It makes the code much easier to reason about.
- **Cancelation:** The Fetch API itself does not have a native way to cancel requests. You must use the `AbortController` interface to achieve this.