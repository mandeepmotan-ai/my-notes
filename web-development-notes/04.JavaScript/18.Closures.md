# Closures

- a closure is created when a function **remembers** the variables from the scope where it was defined, even after that scope has finished executing
- simply, a closure gives us access to outer function’s variable from an inner function even after the outer function is gone
- a closure is the combination of a function and the environment in which that function was created. This environment consists of any local variables that were in-scope at the time the closure was created. When a function is returned or passed, it carries along its scope (variables) with it. This bundle of ***“function + scope”*** is closure

### The Lexical Scoping Foundation

- JS uses lexical scoping which means that a function’s scope (the variable it can access) is determined by where it is written in the source code, not where it is called

### Example:

```jsx
function outer() {
  let count = 0; // outer variable

  function inner() {
    // `inner` is lexically inside `outer`, so it can access `outerVar`
    count++;
    console.log(count);
  }

  return inner;
}

const counter = outer(); // outer is done, but inner "remembers" count

counter(); // 1
counter(); // 2
counter(); // 3
```

Even though `outer()` finished, `inner()` still has access to `count`. That’s closure in action.

## Practical uses of closure:

- a closure is not something we explicitly “create” with a special keyword
- it is a natural and inherent behavior of JS functions that arises from its lexical scoping
- every time a function is created, it forms a closure over its environment
- by understanding this fundamental behavior of functions in JS, we can write more secure, modular and elegant code

### 1. Data Encapsulation and Private Variables

- closures provide a way to create “private” variables in JS, which is useful for protecting data from external, unwanted access
- **Example: a private counter**
    
    ```jsx
    function makeCounter() {
      let privateCount = 0; // This is a private variable
    
      return {
        increment: function() {
          privateCount++;
        },
        decrement: function() {
          privateCount--;
        },
        getValue: function() {
          return privateCount;
        }
      };
    }
    
    const myCounter = makeCounter();
    
    myCounter.increment();
    myCounter.increment();
    console.log(myCounter.getValue()); // Logs: 2
    
    // You cannot directly access `privateCount` from outside
    // console.log(myCounter.privateCount); // This would be undefined
    ```
    
- the inner functions (`increment`, `decrement`, `getValue`) form a closure over `privateCount`, giving them exclusive access to it

### 2. Event Handlers and Asynchronous Operations

- closures are essential for ensuring that event handlers and asynchronous callbacks that access to the variables they need from the scope in which they were defined
- Example: closure in event listeners
    
    ```jsx
    function setupButton(id) {
      let clicks = 0;
      document.getElementById(id).addEventListener("click", function() {
        clicks++;
        console.log(`${id} clicked ${clicks} times`);
      });
    }
    
    setupButton("btn1");
    setupButton("btn2");
    ```
    
    Each button gets its own closure with separate `clicks` variable.
    

### 3. Function Currying

- currying is a technique where a function that takes multiple arguments is transformed into a sequence of functions, each taking a single argument. Closures are what make this possible
    
    ```jsx
    function multiply(a) {
      return function(b) {
        return a * b;
      };
    }
    
    const double = multiply(2);
    const triple = multiply(3);
    
    console.log(double(5));  // The closure remembers a=2, logs 10
    console.log(triple(5));  // The closure remembers a=3, logs 1
    ```